// use std::{collections::BTreeSet, iter::FromIterator};
// use modulo::Mod;

// fn pickupdel<T>(mut items: Vec<T>, to_remove: Vec<T>) -> Vec<T>
// where
//     T: std::cmp::Ord,
// {
//     let to_remove = BTreeSet::from_iter(to_remove);
//     items.retain(|e| !to_remove.contains(e));
//     items
// }

fn inpickup(i: i32, pickup: Vec<i32>) -> bool {
    return pickup.contains(&i)
}

fn getindex(i: i32, v: Vec<i32>) -> i32 {
    return v.iter().position(|&r| r == i).unwrap() as i32
}

fn destidxsearch(v: Vec<i32>, pickup: Vec<i32>, mut destination: i32) -> (i32, i32) {
    while inpickup(destination.clone(), pickup.clone()) {
        destination = destination - 1;
        if destination < 0 {
            destination = 1000000;
        }
    }
    return (destination, getindex(destination, v) as i32) 
}

// https://stackoverflow.com/a/47039490/9307482

fn main() {
    let mut v = vec![3,8,9,1,2,5,4,6,7];
    // let mut v = vec![3,8,9,1,2,5,4,6,7,10,11,12,13,14,15];
    // let mut v = vec![4,5,9,6,7,2,8,1,3];
    
    // for n in 10..1000001 {
    //     // println!("{}",n);
    //     v.push(n);
    // }
    
    let mut index = 0;
    let mut moveno = 1;

    // while moveno < 10000000 {
    for _ in 0..10 {
        println!("in loop {:?}", v);
        
        let idx1 =
            if index + 1 > 1000000 {
                index % 1000000
            } else {
                index + 1
            };
        let idx2 =
            if index + 2 > 1000000 {
                index % 1000000
            } else {
                index + 2
            };
        let idx3 =
            if index + 3 > 1000000 {
                index % 1000000
            } else {
                index + 3
            };
        let mut pickup: Vec<i32> = Vec::new();
        println!("move {}", moveno);
        println!("indexe {} {} {}", idx1, idx2, idx3);
        pickup.push(v[idx1]);
        pickup.push(v[idx2]);
        pickup.push(v[idx3]);
        println!("pickup after{:?}", pickup);

        let destination = &v[index] - 1;
        println!("destination {:?}", destination);
        
        v.retain(|&x| ! pickup.contains(&x));

        let destidx = 0;

        if !inpickup(destination, v.clone()) {
            let (destination, destidx) = destidxsearch(v.clone(), pickup.clone(), destination.clone());
        }
        println!("destination {:?}", destination);

        println!("old vec {:?}\n", v);
        v.insert(destidx + 2, pickup[0]);
        v.insert(destidx + 3, pickup[1]);
        v.insert(destidx + 4, pickup[2]);

        println!("new vec {:?}\n", v);

        index = index + 1;
        moveno = moveno + 1;
    }
}
